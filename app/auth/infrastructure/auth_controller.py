from fastapi import APIRouter, Depends, HTTPException, status, Response, Cookie
from dependency_injector.wiring import inject, Provide

from app.common.domain import ValueId
from app.common.infrastructure import JwtAdapter

from app.auth.application import AuthenticateUser, CredentialsError
from app.auth.domain import AuthIn
from app.auth.infrastructure import AuthTokenError, Token, GetUserPayload

from app.user.application import UserExists

router = APIRouter(
    prefix="/auth",
    tags=["auth"]
)


@router.post(
    path="/token",
    response_model=Token
)
@inject
async def login(
    response: Response,
    auth: AuthIn,
    authenticate_user: AuthenticateUser = Depends(Provide["services.authenticate_user"])
):
    """
    Authenticates the user and generates an access token and a refresh token.

    Parameters:
        response (Response): A FastAPI `Response` object that is used to generate the HTTP response
        for the login endpoint.
        auth (AuthIn): An instance of an `AuthIn` class that includes an email and password for authentication.
        authenticate_user (AuthenticateUser): A dependency that injects an instance of an `AuthenticateUser`
        service class used to authenticate the user.

    Returns:
        Response: If authentication is successful, the response generated by `generate_token_response` is returned.

    Raises:
        HTTPException: If authentication fails due to an incorrect email or password, an HTTPException is raised with a
        401 status code and the error message.
    """
    try:
        user_id = authenticate_user(auth.email, auth.password)

        access_token, refresh_token = generate_tokens(user_id)

        register_refresh_token_to_cookies(response, refresh_token)

        return Token(
            access_token=access_token,
            token_type="bearer"
        )
    except CredentialsError as error:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(error)
        )


@router.post(
    path="/token/refresh",
    response_model=Token
)
@inject
async def refresh(
    refresh_token: str = Cookie(None),
    user_exists: UserExists = Depends(Provide["services.user_exists"]),
    get_user_payload: GetUserPayload = Depends(Provide["services.get_user_payload"])
):
    """
        Authenticates the user using a refresh token and generates a new access token.

        Parameters:
            refresh_token (str): A string that contains the refresh token passed in as a cookie.
            user_exists (UserExists): A dependency that injects an instance of a `UserExists` service class used
            to check if a user exists.
            get_user_payload (GetUserPayload): A dependency that injects an instance of a `GetUserPayload`
            service class used to extract the user ID from the refresh token.

        Returns:
            Response: If the refresh token is valid, a `Token` object is returned.

        Raises:
            AuthTokenError: If the refresh token is missing or invalid, an `AuthTokenError` is raised with an
            error message.
        """
    if not refresh_token:
        raise AuthTokenError("missing refresh token")

    # Get user_id from the refresh_token
    payload = get_user_payload(refresh_token)

    if not user_exists(payload.user_id):
        raise AuthTokenError("invalid refresh token")

    # Generate new tokens
    access_token, _ = generate_tokens(payload.user_id)

    return Token(
        access_token=access_token,
        token_type="bearer"
    )


@inject
def generate_tokens(
    user_id: ValueId,
    jwt: JwtAdapter = Depends(Provide["services.jwt"])
) -> tuple[str, str]:
    """
    Generates an access token and a refresh token for the specified user.

    Parameters:
        user_id (ValueId): A `ValueId` representing the ID of the user for whom the tokens are being generated.
        jwt (JwtAdapter, optional): A `JwtAdapter` instance that is used to generate the access and refresh tokens.

    Returns:
        tuple[str, str]: A tuple containing the `access_token` and the `refresh_token`.
    """
    identifier = f"user_id:{user_id}"
    access_token = jwt.create_access_token(identifier)
    refresh_token = jwt.create_refresh_token(identifier)

    return access_token, refresh_token


def register_refresh_token_to_cookies(
    response: Response,
    refresh_token: str
):
    """
    Generates an HTTP response with a refresh token as a cookie.

    Parameters:
        response (Response): A FastAPI `Response` object that is used to generate the HTTP
        response for the token endpoint.
        refresh_token (str): A string that contains the refresh token to be set as a cookie in the response.
    """

    refresh_token_expire_seconds = JwtAdapter.REFRESH_TOKEN_EXPIRE_MINUTES * 60

    # This code sets an HTTP-only cookie named refresh_token in the HTTP response.
    # The httponly flag is set to True, which prevents the cookie from being accessed by JavaScript.
    # The path parameter is set to /auth/token/refresh, which restricts the cookie
    # to only be sent to requests made to this path.
    response.set_cookie(
        key="refresh_token",
        value=refresh_token,
        httponly=True,
        secure=True,
        samesite="none",
        max_age=refresh_token_expire_seconds,
        path="/auth/token/refresh"
    )

